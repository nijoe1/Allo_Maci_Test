"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Circomkit = void 0;
const snarkjs = __importStar(require("snarkjs"));
const wasm_tester = require('circom_tester').wasm;
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const crypto_1 = require("crypto");
const loglevel_1 = require("loglevel");
const child_process_1 = require("child_process");
const utils_1 = require("./utils/");
const ptau_1 = require("./utils/ptau");
const testers_1 = require("./testers/");
const utils_2 = require("./utils");
const config_1 = require("./utils/config");
const calldata_1 = require("./utils/calldata");
const r1cs_1 = require("./utils/r1cs");
/**
 * Circomkit is an opinionated wrapper around many SnarkJS functions.
 *
 * It abstracts away all the path and commands by providing a simple interface,
 * built around just providing the circuit name and the input name.
 *
 * ```ts
 * const circomkit = new Circomkit()
 * ```
 *
 * It also provides a **WitnessTester** and a **ProofTester** module which use Chai assertions within.
 *
 * ```ts
 * const witnessTester = await circomkit.WitnessTester(circuitName, circuitConfig)
 * const proofTester = await circomkit.ProofTester(circuitName)
 * ```
 */
class Circomkit {
    constructor(overrides = {}) {
        // override default options with the user-provided ones
        // we can do this via two simple spreads because both objects are single depth
        const config = {
            ...config_1.defaultConfig,
            ...overrides,
        };
        this.config = JSON.parse(JSON.stringify(config));
        this.logger = (0, loglevel_1.getLogger)('Circomkit');
        this.logger.setLevel(this.config.logLevel);
        // logger for SnarkJS, accepted as an optional argument within their functions
        this.snarkjsLogger = this.config.verbose ? this.logger : undefined;
        // sanity checks
        if (!config_1.PRIMES.includes(this.config.prime)) {
            throw new Error('Invalid prime in configuration.');
        }
        if (!config_1.PROTOCOLS.includes(this.config.protocol)) {
            throw new Error('Invalid protocol in configuration.');
        }
        if (this.config.optimization < 0) {
            this.log('Optimization level must be at least 0, setting it to 0.', 'warn');
            this.config.optimization = 0;
        }
        // PLONK protocol requires optimization level to be 1
        if (this.config.protocol === 'plonk' && this.config.optimization !== 1) {
            this.log('Optimization level for PLONK must be 1.\nSee: https://docs.circom.io/circom-language/circom-insight/simplification/', 'warn');
            this.config.optimization = 1;
        }
    }
    /** Parse circuit config from `circuits.json`. */
    readCircuitConfig(circuit) {
        const circuits = JSON.parse((0, fs_1.readFileSync)(this.config.circuits, 'utf-8'));
        if (!(circuit in circuits)) {
            throw new Error('No such circuit in ' + this.config.circuits);
        }
        return circuits[circuit];
    }
    /** Computes a path that requires a circuit name. */
    path(circuit, type) {
        const dir = `${this.config.dirBuild}/${circuit}`;
        switch (type) {
            case 'dir':
                return dir;
            case 'main':
                return `${this.config.dirCircuits}/main/${circuit}.circom`;
            case 'r1cs':
                return `${dir}/${circuit}.r1cs`;
            case 'sym':
                return `${dir}/${circuit}.sym`;
            case 'wasm':
                return `${dir}/${circuit}_js/${circuit}.wasm`;
            case 'pkey':
                return `${dir}/${this.config.protocol}_pkey.zkey`;
            case 'vkey':
                return `${dir}/${this.config.protocol}_vkey.json`;
            case 'sol':
                return `${dir}/${this.config.protocol}_verifier.sol`;
            default:
                throw new Error('Invalid type: ' + type);
        }
    }
    /** Computes a path that requires a circuit and an input name. */
    pathWithInput(circuit, input, type) {
        const dir = `${this.config.dirBuild}/${circuit}/${input}`;
        switch (type) {
            case 'dir':
                return dir;
            case 'wtns':
                return `${dir}/witness.wtns`;
            case 'pubs':
                return `${dir}/public.json`;
            case 'proof':
                return `${dir}/${this.config.protocol}_proof.json`;
            case 'in':
                return `${this.config.dirInputs}/${circuit}/${input}.json`;
            default:
                throw new Error('Invalid type: ' + type);
        }
    }
    /** Given a PTAU name, returns the relative path. */
    pathPtau(ptauName) {
        return `${this.config.dirPtau}/${ptauName}`;
    }
    /** Given a circuit & id name, returns the relative path of the phase-2 PTAU.
     * This is used in particular by Groth16's circuit-specific setup phase. */
    pathZkey(circuit, id) {
        return `${this.config.dirBuild}/${circuit}/${circuit}_${id}.zkey`;
    }
    /** Colorful logging using the internal logger */
    log(message, type = 'info') {
        // TODO: this is very smelly code, find a better way
        if (type === 'title' || type === 'success') {
            this.logger.info(`${config_1.colors[type]}${message}\x1b[0m`);
        }
        else {
            this.logger[type](`${config_1.colors[type]}${message}\x1b[0m`);
        }
    }
    /** Clean build files and the `main` component of a circuit. */
    async clean(circuit) {
        await Promise.all([
            (0, promises_1.rm)(this.path(circuit, 'dir'), { recursive: true, force: true }),
            (0, promises_1.rm)(this.path(circuit, 'main'), { force: true }),
        ]);
    }
    /** Export a verification key (vKey) from a proving key (zKey). */
    async vkey(circuit, pkeyPath) {
        const vkeyPath = this.path(circuit, 'vkey');
        // check if it exists
        if (pkeyPath === undefined) {
            pkeyPath = this.path(circuit, 'pkey');
        }
        if (!(0, fs_1.existsSync)(pkeyPath)) {
            throw new Error('There must be a prover key for this circuit to extract a verification key.');
        }
        // extract it
        const vkey = await snarkjs.zKey.exportVerificationKey(pkeyPath, this.snarkjsLogger);
        (0, fs_1.writeFileSync)(vkeyPath, (0, utils_2.prettyStringify)(vkey));
        return vkeyPath;
    }
    /** Read the information about the circuit by extracting it from the R1CS file.
     *
     * This implementation follows the specs at [iden3/r1csfile](https://github.com/iden3/r1csfile/blob/master/doc/r1cs_bin_format.md)
     * and is inspired from the work by [PSE's `p0tion`](https://github.com/privacy-scaling-explorations/p0tion/blob/f88bcee5d499dce975d0592ed10b21aa8d73bbd2/packages/actions/src/helpers/utils.ts#L413)
     * and by [Weijiekoh's `circom-helper`](https://github.com/weijiekoh/circom-helper/blob/master/ts/read_num_inputs.ts#L5).
     */
    async info(circuit) {
        let pointer = 0;
        const r1csInfoType = {
            wires: 0,
            constraints: 0,
            privateInputs: 0,
            publicInputs: 0,
            publicOutputs: 0,
            useCustomGates: false,
            labels: 0,
            prime: BigInt(0),
            primeName: '',
        };
        // Open the file (read mode).
        const fd = (0, fs_1.openSync)(this.path(circuit, 'r1cs'), 'r');
        // Get 'number of section' (jump magic r1cs and version1 data).
        const numberOfSections = (0, r1cs_1.readBytesFromFile)(fd, 0, 4, 8);
        pointer = 12;
        for (let i = Number(numberOfSections); i >= 0; i--) {
            const sectionType = Number((0, r1cs_1.readBytesFromFile)(fd, 0, 4, pointer));
            pointer += 4;
            const sectionSize = Number((0, r1cs_1.readBytesFromFile)(fd, 0, 8, pointer));
            pointer += 8;
            switch (sectionType) {
                // Header section.
                case 1:
                    // Field size (skip).
                    pointer += 4;
                    r1csInfoType.prime = (0, r1cs_1.readBytesFromFile)(fd, 0, 32, pointer).toString();
                    pointer += 32;
                    r1csInfoType.wires = Number((0, r1cs_1.readBytesFromFile)(fd, 0, 4, pointer));
                    pointer += 4;
                    r1csInfoType.publicOutputs = Number((0, r1cs_1.readBytesFromFile)(fd, 0, 4, pointer));
                    pointer += 4;
                    r1csInfoType.publicInputs = Number((0, r1cs_1.readBytesFromFile)(fd, 0, 4, pointer));
                    pointer += 4;
                    r1csInfoType.privateInputs = Number((0, r1cs_1.readBytesFromFile)(fd, 0, 4, pointer));
                    pointer += 4;
                    r1csInfoType.labels = Number((0, r1cs_1.readBytesFromFile)(fd, 0, 8, pointer));
                    pointer += 8;
                    r1csInfoType.constraints = Number((0, r1cs_1.readBytesFromFile)(fd, 0, 4, pointer));
                    pointer += 4;
                    break;
                // Custom gates list section (plonk only).
                case 4:
                    r1csInfoType.useCustomGates = Number((0, r1cs_1.readBytesFromFile)(fd, 0, 4, pointer)) > 0 ? true : false;
                    pointer += Number(sectionSize);
                    break;
                default:
                    pointer += Number(sectionSize);
                    break;
            }
        }
        r1csInfoType.primeName = utils_2.primeToName[r1csInfoType.prime.toString()];
        return r1csInfoType;
    }
    /** Downloads the phase-1 setup PTAU file for a circuit based on it's number of constraints.
     *
     * The downloaded PTAU files can be seen at [SnarkJS docs](https://github.com/iden3/snarkjs#7-prepare-phase-2).
     * Note that this may take a while if the circuit is large and thus a larger PTAU is needed.
     *
     * This function only works when the used prime is `bn128`.
     *
     * @returns path of the downloaded PTAU file
     */
    async ptau(circuit) {
        if (this.config.prime !== 'bn128') {
            throw new Error('Auto-downloading PTAU only allowed for bn128 at the moment.');
        }
        // @todo check for performance gains when larger PTAUs are found instead of the target PTAU
        const { constraints } = await this.info(circuit);
        const ptauName = (0, ptau_1.getPtauName)(constraints);
        // return if ptau exists already
        const ptauPath = this.pathPtau(ptauName);
        if ((0, fs_1.existsSync)(ptauPath)) {
            return ptauPath;
        }
        else {
            (0, fs_1.mkdirSync)(this.config.dirPtau, { recursive: true });
            this.log('Downloading ' + ptauName + '...');
            return await (0, ptau_1.downloadPtau)(ptauName, this.config.dirPtau);
        }
    }
    /** Compile the circuit.
     *
     * A circuit configuration can be passed optionally; if not, the
     * config will be read from `circuits.json` at the working directory.
     *
     * @returns path of the build directory
     */
    async compile(circuit, config) {
        const targetPath = this.instantiate(circuit, config);
        this.log('Main component created at: ' + targetPath, 'debug');
        const outDir = this.path(circuit, 'dir');
        (0, fs_1.mkdirSync)(outDir, { recursive: true });
        // prettier-ignore
        let flags = `--sym --wasm --r1cs -p ${this.config.prime} -o ${outDir}`;
        if (this.config.include.length > 0)
            flags += ' ' + this.config.include.map(path => `-l ${path}`).join(' ');
        if (this.config.verbose)
            flags += ' --verbose';
        if (this.config.inspect)
            flags += ' --inspect';
        if (this.config.cWitness)
            flags += ' --c';
        if (this.config.optimization > 2) {
            // --O2round <value>
            flags += ` --O2round ${this.config.optimization}`;
        }
        else {
            // --O0, --O1 or --O2
            flags += ` --O${this.config.optimization}`;
        }
        // call `circom` as a sub-process
        try {
            const result = await new Promise((resolve, reject) => {
                (0, child_process_1.exec)(`${this.config.circomPath} ${flags} ${targetPath}`, (error, stdout, stderr) => {
                    if (error === null) {
                        resolve({ stdout, stderr });
                    }
                    else {
                        reject(error);
                    }
                });
            });
            if (this.config.verbose) {
                this.log(result.stdout);
            }
            if (result.stderr) {
                this.log(result.stderr, 'error');
            }
        }
        catch (e) {
            throw new Error('Compiler error:\n' + e);
        }
        return outDir;
    }
    /** Exports a solidity contract for the verifier.
     * @returns path of the exported Solidity contract
     */
    async contract(circuit) {
        const pkey = this.path(circuit, 'pkey');
        const template = (0, fs_1.readFileSync)(`./node_modules/snarkjs/templates/verifier_${this.config.protocol}.sol.ejs`, 'utf-8');
        const contractCode = await snarkjs.zKey.exportSolidityVerifier(pkey, { [this.config.protocol]: template }, this.snarkjsLogger);
        const contractPath = this.path(circuit, 'sol');
        (0, fs_1.writeFileSync)(contractPath, contractCode);
        return contractPath;
    }
    /** Export calldata to call a Verifier contract.
     * @returns calldata
     */
    async calldata(circuit, input) {
        const pubs = JSON.parse(await (0, promises_1.readFile)(this.pathWithInput(circuit, input, 'pubs'), 'utf-8'));
        const proof = JSON.parse(await (0, promises_1.readFile)(this.pathWithInput(circuit, input, 'proof'), 'utf-8'));
        // const res = await snarkjs[this.config.protocol].exportSolidityCallData(proof as any, pubs as any);
        const res = (0, calldata_1.getCalldata)(proof, pubs, this.config.prettyCalldata);
        return res;
    }
    /** Instantiate the `main` component.
     *
     * If `circuitConfig` argument is omitted, this function will look for it at `circuits.json`
     * in the working directory, and throw an error if no entry is found for the circuit.
     *
     * When config is read from file, `dir` defaults to `main`, otherwise `dir` defaults to `test`.
     * This is done to make it so that when CLI is used circuits are created under `main`, and when
     * we use Circomkit programmatically (e.g. during testing) circuits are created under `test`
     * unless specified otherwise.
     *
     * @returns path of the created main component
     */
    instantiate(circuit, circuitConfig) {
        if (!circuitConfig) {
            const circuitConfigFile = this.readCircuitConfig(circuit);
            circuitConfig = {
                ...circuitConfigFile,
                dir: circuitConfigFile.dir || 'main',
                version: circuitConfigFile.version || this.config.version,
            };
        }
        // directory to output the file
        const directory = circuitConfig.dir || 'test';
        // add "../" to the filename in include, one for each "/" in directory name
        // if none, the prefix becomes empty string
        const filePrefixMatches = directory.match(/\//g);
        let file = circuitConfig.file;
        if (filePrefixMatches !== null) {
            file = '../'.repeat(filePrefixMatches.length) + file;
        }
        // generate the code for `main` component
        const circuitCode = (0, utils_1.makeCircuit)({
            file: file,
            template: circuitConfig.template,
            version: circuitConfig.version || '2.0.0',
            dir: directory,
            pubs: circuitConfig.pubs || [],
            params: circuitConfig.params || [],
        });
        // check the target directory
        const targetDir = `${this.config.dirCircuits}/${directory}`;
        if (!(0, fs_1.existsSync)(targetDir)) {
            (0, fs_1.mkdirSync)(targetDir, {
                recursive: true,
            });
        }
        // write main component to file
        const targetPath = `${targetDir}/${circuit}.circom`;
        (0, fs_1.writeFileSync)(targetPath, circuitCode);
        return targetPath;
    }
    /** Generate a proof.
     *
     * If `data` is not passed, the input data will be read from `inputs/<circuit>/<input>.json`.
     *
     * @returns path of the directory where public signals and proof are created
     */
    async prove(circuit, input, data) {
        // create WASM if needed
        const wasmPath = this.path(circuit, 'wasm');
        if (!(0, fs_1.existsSync)(wasmPath)) {
            this.log('WASM file does not exist, creating it now...', 'warn');
            await this.compile(circuit);
        }
        // create PKEY if needed
        const pkeyPath = this.path(circuit, 'pkey');
        if (!(0, fs_1.existsSync)(pkeyPath)) {
            this.log('Prover key does not exist, creating it now...', 'warn');
            await this.setup(circuit);
        }
        const jsonInput = data || JSON.parse((0, fs_1.readFileSync)(this.pathWithInput(circuit, input, 'in'), 'utf-8'));
        const { proof, publicSignals } = await snarkjs[this.config.protocol].fullProve(jsonInput, wasmPath, pkeyPath, this.snarkjsLogger);
        const dir = this.pathWithInput(circuit, input, 'dir');
        (0, fs_1.mkdirSync)(dir, { recursive: true });
        await Promise.all([
            (0, promises_1.writeFile)(this.pathWithInput(circuit, input, 'pubs'), (0, utils_2.prettyStringify)(publicSignals)),
            (0, promises_1.writeFile)(this.pathWithInput(circuit, input, 'proof'), (0, utils_2.prettyStringify)(proof)),
        ]);
        return dir;
    }
    /** Commence a circuit-specific setup.
     *
     * If `ptauPath` argument is omitted, this function will try to automatically download it.
     * See the {@link ptau} method for more information about this.
     *
     * @returns path of the verifier key and prover key
     */
    async setup(circuit, ptauPath) {
        const r1csPath = this.path(circuit, 'r1cs');
        const pkeyPath = this.path(circuit, 'pkey');
        const vkeyPath = this.path(circuit, 'vkey');
        // create R1CS if needed
        if (!(0, fs_1.existsSync)(r1csPath)) {
            this.log('R1CS does not exist, creating it now...', 'warn');
            await this.compile(circuit);
        }
        // get ptau path
        this.log('Checking for PTAU file...', 'debug');
        if (ptauPath === undefined) {
            // if no ptau is given, we can download it
            if (this.config.prime !== 'bn128') {
                throw new Error('Please provide PTAU file when using a prime field other than bn128');
            }
            ptauPath = await this.ptau(circuit);
        }
        else if (!(0, fs_1.existsSync)(ptauPath)) {
            // if the provided path does not exist, we can download it anyways
            this.log('PTAU path was given but no PTAU exists there, downloading it anyways.', 'warn');
            ptauPath = await this.ptau(circuit);
        }
        // circuit specific setup
        this.log('Beginning setup phase!', 'info');
        if (this.config.protocol === 'groth16') {
            // Groth16 needs a circuit specific setup
            // generate genesis zKey
            let curZkey = this.pathZkey(circuit, 0);
            await snarkjs.zKey.newZKey(r1csPath, ptauPath, curZkey, this.snarkjsLogger);
            // make contributions
            for (let contrib = 1; contrib <= this.config.groth16numContributions; contrib++) {
                const nextZkey = this.pathZkey(circuit, contrib);
                // entropy, if user wants to prompt give undefined
                this.log(`Making contribution: ${contrib}`, 'info');
                await snarkjs.zKey.contribute(curZkey, nextZkey, `${circuit}_${contrib}`, this.config.groth16askForEntropy ? undefined : (0, crypto_1.randomBytes)(32), // entropy
                this.snarkjsLogger);
                // remove current key, and move on to next one
                (0, fs_1.rmSync)(curZkey);
                curZkey = nextZkey;
            }
            // finally, rename the resulting key to pkey
            (0, fs_1.renameSync)(curZkey, pkeyPath);
        }
        else {
            // PLONK or FFLONK don't need specific setup
            await snarkjs[this.config.protocol].setup(r1csPath, ptauPath, pkeyPath, this.snarkjsLogger);
        }
        // export verification key
        const vkey = await snarkjs.zKey.exportVerificationKey(pkeyPath, this.snarkjsLogger);
        (0, fs_1.writeFileSync)(vkeyPath, (0, utils_2.prettyStringify)(vkey));
        return { verifierKeyPath: vkeyPath, proverKeyPath: pkeyPath };
    }
    /** Verify a proof for some public signals.
     * @returns `true` if verification is successful, `false` otherwise.
     */
    async verify(circuit, input) {
        const [vkey, pubs, proof] = (await Promise.all([
            this.path(circuit, 'vkey'),
            this.pathWithInput(circuit, input, 'pubs'),
            this.pathWithInput(circuit, input, 'proof'),
        ].map(path => (0, promises_1.readFile)(path, 'utf-8')))).map(content => JSON.parse(content));
        return await snarkjs[this.config.protocol].verify(vkey, pubs, proof, this.snarkjsLogger);
    }
    /** Calculates the witness for the given circuit and input.
     *
     * If `data` is not passed, the input data will be read from `inputs/<circuit>/<input>.json`.
     *
     * @returns path of the created witness
     */
    async witness(circuit, input, data) {
        const wasmPath = this.path(circuit, 'wasm');
        const wtnsPath = this.pathWithInput(circuit, input, 'wtns');
        const outDir = this.pathWithInput(circuit, input, 'dir');
        const jsonInput = data || JSON.parse((0, fs_1.readFileSync)(this.pathWithInput(circuit, input, 'in'), 'utf-8'));
        (0, fs_1.mkdirSync)(outDir, { recursive: true });
        await snarkjs.wtns.calculate(jsonInput, wasmPath, wtnsPath);
        return wtnsPath;
    }
    /** Exports a JSON input file for some circuit with the given object.
     *
     * This is useful for testing real circuits, or creating an input programmatically.
     * Overwrites an existing input.
     *
     * @returns path of the created input file
     */
    input(circuit, input, data) {
        const inputPath = this.pathWithInput(circuit, input, 'in');
        if ((0, fs_1.existsSync)(inputPath)) {
            this.log('Input file exists already, overwriting it.', 'warn');
        }
        (0, fs_1.writeFileSync)(inputPath, (0, utils_2.prettyStringify)(data));
        return inputPath;
    }
    /** Export a circuit artifact in JSON format.
     *
     * Returns the JSON object itself, and the path that it would be exported to with
     * respect to the Circomkit configuration.
     *
     * @returns a JSON object or the path that it would be exported to.
     */
    async json(type, circuit, input) {
        let json;
        let path;
        switch (type) {
            // R1CS
            case 'r1cs': {
                path = this.path(circuit, 'r1cs');
                json = await snarkjs.r1cs.exportJson(path, undefined); // internal log didnt make sense
                break;
            }
            // Prover key
            case 'zkey': {
                // must be groth16, others give error (tested at snarkjs v0.7.0)
                if (this.config.protocol !== 'groth16') {
                    throw new Error('Exporting zKey to JSON is only supported for Groth16 at the moment.');
                }
                path = this.path(circuit, 'pkey');
                json = await snarkjs.zKey.exportJson(path);
                break;
            }
            // Witness
            case 'wtns': {
                if (!input)
                    throw new Error('Expected input');
                path = this.pathWithInput(circuit, input, 'wtns');
                json = await snarkjs.wtns.exportJson(path);
                break;
            }
            default:
                throw new Error('Unknown export target: ' + type);
        }
        return {
            json,
            path: path + '.json',
        };
    }
    /** Compiles the circuit and returns a witness tester instance. */
    async WitnessTester(circuit, circuitConfig) {
        circuitConfig.dir ?? (circuitConfig.dir = 'test'); // defaults to test directory
        const targetPath = this.instantiate(circuit, circuitConfig);
        const circomWasmTester = await wasm_tester(targetPath, {
            output: undefined, // this makes tests to be created under /tmp
            prime: this.config.prime,
            verbose: this.config.verbose,
            O: Math.min(this.config.optimization, 1), // tester doesnt have O2
            json: false,
            include: this.config.include,
            wasm: true,
            sym: true,
            recompile: circuitConfig.recompile ?? true,
        });
        return new testers_1.WitnessTester(circomWasmTester);
    }
    /** Returns a proof tester. */
    async ProofTester(circuit) {
        const wasmPath = this.path(circuit, 'wasm');
        const pkeyPath = this.path(circuit, 'pkey');
        const vkeyPath = this.path(circuit, 'vkey');
        // check if all files are present
        const missingPaths = [wasmPath, pkeyPath, vkeyPath].filter(p => !(0, fs_1.existsSync)(p));
        if (missingPaths.length !== 0) {
            throw new Error('Missing files: ' + missingPaths.join(', '));
        }
        return new testers_1.ProofTester(wasmPath, pkeyPath, vkeyPath);
    }
}
exports.Circomkit = Circomkit;
//# sourceMappingURL=circomkit.js.map