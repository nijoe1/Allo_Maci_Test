"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProofTester = void 0;
const snarkjs = require('snarkjs');
const chai_1 = require("chai");
const fs_1 = require("fs");
/** A tester that is able to generate proofs & verify them.
 * Use `expectFail` and `expectPass` to test out evaluations. */
class ProofTester {
    constructor(wasmPath, pkeyPath, vkeyPath) {
        this.wasmPath = wasmPath;
        this.pkeyPath = pkeyPath;
        this.vkeyPath = vkeyPath;
        this.verificationKey = JSON.parse((0, fs_1.readFileSync)(vkeyPath).toString());
        this.protocol = this.verificationKey.protocol;
    }
    /** Generate a proof for the witness computed from the given input signals. */
    async prove(input) {
        return await snarkjs[this.protocol].fullProve(input, this.wasmPath, this.pkeyPath, undefined);
    }
    /** Returns the verification result of a proof for some public signals. */
    async verify(proof, publicSignals) {
        return await snarkjs[this.protocol].verify(this.verificationKey, publicSignals, proof);
    }
    /** Expects a verification to pass for this proof and public signals. */
    async expectPass(proof, publicSignals) {
        (0, chai_1.expect)(await this.verify(proof, publicSignals), 'Expected proof to be verified.').to.be.true;
    }
    /** Expects a verification to fail for this proof and public signals. */
    async expectFail(proof, publicSignals) {
        (0, chai_1.expect)(await this.verify(proof, publicSignals), 'Expected proof to be not verified.').to.be.false;
    }
}
exports.ProofTester = ProofTester;
//# sourceMappingURL=proofTester.js.map