import type { CircomWasmTester, WitnessType, CircuitSignals } from '../types/';
/** A utility class to test your circuits. Use `expectFail` and `expectPass` to test out evaluations. */
export declare class WitnessTester<IN extends readonly string[] = [], OUT extends readonly string[] = []> {
    /** The underlying `circom_tester` object */
    private readonly circomWasmTester;
    /** A dictionary of symbols, see {@link loadSymbols} */
    private symbols;
    /** List of constraints, see {@link loadConstraints} */
    private constraints;
    constructor(circomWasmTester: CircomWasmTester);
    /** Assert that constraints are valid for a given witness. */
    expectConstraintPass(witness: WitnessType): Promise<void>;
    /**
     * Assert that constraints are NOT valid for a given witness.
     * This is useful to test if a fake witness (a witness from a
     * dishonest prover) can still be valid, which would indicate
     * that there are soundness errors in the circuit.
     */
    expectConstraintFail(witness: WitnessType): Promise<void>;
    /** Compute witness given the input signals. */
    calculateWitness(input: CircuitSignals<IN>): Promise<WitnessType>;
    /** Returns the number of constraints. */
    getConstraintCount(): Promise<number>;
    /** Asserts that the circuit has enough constraints.
     *
     * By default, this function checks if there **at least** `expected` many constraints in the circuit.
     * If `exact` option is set to `true`, it will also check if the number of constraints is exactly equal to
     * the `expected` amount.
     *
     * If first check fails, it means the circuit is under-constrained. If the second check fails, it means
     * the circuit is over-constrained.
     */
    expectConstraintCount(expected: number, exact?: boolean): Promise<void>;
    /** Expect a witness computation to fail in the circuit.
     *
     * See [here](https://github.com/iden3/circom/blob/master/code_producers/src/wasm_elements/common/witness_calculator.js#L21)
     * for the list of errors that may occur during witness calculation.
     * Most of the time, you will be expecting an assertion error.
     *
     * @returns the error message.
     */
    expectFail(input: CircuitSignals<IN>): Promise<string>;
    /** Expect an input to pass assertions and match the output.
     *
     * If `output` is omitted, it will only check for constraints to pass.
     */
    expectPass(input: CircuitSignals<IN>, output?: CircuitSignals<OUT>): Promise<void>;
    /**
     * Computes the witness.
     * This is a shorthand for calculating the witness and calling {@link readWitnessSignals} on the result.
     */
    compute(input: CircuitSignals<IN>, signals: string[] | OUT): Promise<CircuitSignals>;
    /**
     * Override witness value to try and fake a proof. If the circuit has soundness problems (i.e.
     * some signals are not constrained correctly), then you may be able to create a fake witness by
     * overriding specific values, and pass the constraints check.
     *
     * The symbol names must be given in full form, not just as the signal is named in the circuit code. In
     * general a symbol name looks something like:
     *
     * - `main.signal`
     * - `main.component.signal`
     * - `main.component.signal[n][m]`
     *
     * You will likely call `checkConstraints` on the resulting fake witness to see if it can indeed fool
     * a verifier.
     * @see {@link checkConstraints}
     */
    editWitness(witness: Readonly<WitnessType>, symbolValues: {
        [symbolName: string]: bigint;
    }): Promise<WitnessType>;
    /** Read symbol values from a witness. */
    readWitness(witness: Readonly<WitnessType>, symbols: string[]): Promise<Record<string, bigint>>;
    /**
     * Read signals from a witness.
     *
     * This is not the same as {@link readWitness} in the sense that the entire value represented by a signal
     * will be returned here. For example, instead of reading `main.out[0], main.out[1], main.out[2]` with `readWitness`,
     * you can simply query `out` in this function and an object with `{out: [...]}` will be returned.
     *
     * To read signals within a component, simply refer to them as `component.signal`. In other words, omit the `main.` prefix
     * and array dimensions.
     */
    readWitnessSignals(witness: Readonly<WitnessType>, signals: string[] | OUT): Promise<CircuitSignals>;
    /**
     * Assert the output of a given witness.
     * @param actualOut expected witness
     * @param expectedOut computed output signals
     */
    private assertOut;
    /** Loads the list of R1CS constraints to `this.constraints`. */
    private loadConstraints;
    /**
     * Loads the symbols in a dictionary at `this.symbols`
     * Symbols are stored under the .sym file
     *
     * Each line has 4 comma-separated values:
     *
     * 1.  symbol name
     * 2.  label index
     * 3.  variable index
     * 4.  component index
     */
    private loadSymbols;
    /**
     * @deprecated this is buggy right now
     * @param witness witness
     */
    private getDecoratedOutput;
    /**
     * Cleanup directory, should probably be called upon test completion (?)
     * @deprecated this is buggy right now
     */
    private release;
}
