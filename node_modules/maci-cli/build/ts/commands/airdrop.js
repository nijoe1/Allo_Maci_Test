"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.airdrop = void 0;
const maci_contracts_1 = require("maci-contracts");
const utils_1 = require("../utils");
/**
 * Utility that can be used to get
 * topup credits airdropped
 * to the coordinator
 * @param AirdropArgs - The arguments for the airdrop command
 */
const airdrop = async ({ amount, contractAddress, pollId, maciAddress, signer, quiet = true, }) => {
    (0, utils_1.banner)(quiet);
    const network = await signer.provider?.getNetwork();
    // get the topup credit address from storage
    const topupCredit = (0, utils_1.readContractAddress)("TopupCredit", network?.name);
    // we want to ensure that we have either the address stored
    // or that it was passed as a parameter
    if (!topupCredit && !contractAddress) {
        (0, utils_1.logError)("Please provide an ERC20 contract address");
    }
    const ERC20Address = contractAddress || topupCredit;
    // check if the contract exists
    if (!(await (0, utils_1.contractExists)(signer.provider, ERC20Address))) {
        (0, utils_1.logError)("Invalid ERC20 contract address");
    }
    // create the contract instance
    const tokenContract = maci_contracts_1.TopupCredit__factory.connect(ERC20Address, signer);
    if (amount < 0) {
        (0, utils_1.logError)("Invalid amount");
    }
    // try to get the tokens airdropped
    try {
        const tx = await tokenContract.airdrop(amount.toString(), {
            gasLimit: 1000000,
        });
        await tx.wait();
        (0, utils_1.logGreen)(quiet, (0, utils_1.success)(`Airdropped ${amount} credits to ${await signer.getAddress()}`));
    }
    catch (error) {
        (0, utils_1.logError)(error.message);
    }
    // if there is a poll id provided, we can pre-approve all of the tokens
    // so there is no need to do it afterwards
    if (pollId !== undefined) {
        const maciContractAddress = (0, utils_1.readContractAddress)("MACI", network?.name)
            ? (0, utils_1.readContractAddress)("MACI", network?.name)
            : maciAddress;
        if (!maciAddress) {
            (0, utils_1.logError)("Please provide a MACI contract address");
        }
        const maciContract = maci_contracts_1.MACI__factory.connect(maciContractAddress, signer);
        const pollAddr = await maciContract.getPoll(pollId);
        try {
            const tx = await tokenContract.approve(pollAddr, amount, { gasLimit: 1000000 });
            await tx.wait();
            (0, utils_1.logGreen)(quiet, (0, utils_1.success)(`Approved ${pollAddr} to spend ${amount} credits`));
        }
        catch (error) {
            (0, utils_1.logError)(error.message);
        }
    }
};
exports.airdrop = airdrop;
//# sourceMappingURL=airdrop.js.map