"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeMessages = void 0;
const maci_contracts_1 = require("maci-contracts");
const utils_1 = require("../utils");
/**
 * Merge the message queue on chain
 * @param MergeMessagesArgs - The arguments for the mergeMessages command
 */
const mergeMessages = async ({ pollId, quiet = true, maciAddress, numQueueOps, signer, }) => {
    (0, utils_1.banner)(quiet);
    const network = await signer.provider?.getNetwork();
    // maci contract validation
    if (!(0, utils_1.readContractAddress)("MACI", network?.name) && !maciAddress) {
        (0, utils_1.logError)("Could not read contracts");
    }
    const maciContractAddress = maciAddress || (0, utils_1.readContractAddress)("MACI", network?.name);
    if (!(await (0, utils_1.contractExists)(signer.provider, maciContractAddress))) {
        (0, utils_1.logError)("MACI contract does not exist");
    }
    if (pollId < 0) {
        (0, utils_1.logError)("Invalid poll id");
    }
    const maciContract = maci_contracts_1.MACI__factory.connect(maciContractAddress, signer);
    const pollAddress = await maciContract.polls(pollId);
    if (!(await (0, utils_1.contractExists)(signer.provider, pollAddress))) {
        (0, utils_1.logError)("Poll contract does not exist");
    }
    const pollContract = maci_contracts_1.Poll__factory.connect(pollAddress, signer);
    const extContracts = await pollContract.extContracts();
    const messageAqContractAddr = extContracts.messageAq;
    const accQueueContract = maci_contracts_1.AccQueue__factory.connect(messageAqContractAddr, signer);
    // we need to ensure that the signer is the owner of the poll contract
    // this is because only the owner can merge the message AQ
    const pollOwner = await pollContract.owner();
    const signerAddress = await signer.getAddress();
    if (pollOwner.toLowerCase() !== signerAddress.toLowerCase()) {
        (0, utils_1.logError)("The signer is not the owner of this Poll contract");
    }
    // check if it's time to merge the message AQ
    const dd = await pollContract.getDeployTimeAndDuration();
    const deadline = Number(dd[0]) + Number(dd[1]);
    const now = await (0, utils_1.currentBlockTimestamp)(signer.provider);
    if (now < deadline) {
        (0, utils_1.logError)("The voting period is not over yet");
    }
    let subTreesMerged = false;
    // infinite loop to merge the sub trees
    while (!subTreesMerged) {
        // eslint-disable-next-line no-await-in-loop
        subTreesMerged = await accQueueContract.subTreesMerged();
        if (subTreesMerged) {
            (0, utils_1.logGreen)(quiet, (0, utils_1.success)("All message subtrees have been merged."));
        }
        else {
            // eslint-disable-next-line no-await-in-loop
            await accQueueContract
                .getSrIndices()
                .then((data) => data.map((x) => Number(x)))
                .then((indices) => {
                (0, utils_1.logYellow)(quiet, (0, utils_1.info)(`Merging message subroots ${indices[0] + 1} / ${indices[1] + 1}`));
            });
            // eslint-disable-next-line no-await-in-loop
            const tx = await pollContract.mergeMessageAqSubRoots(numQueueOps || utils_1.DEFAULT_SR_QUEUE_OPS);
            // eslint-disable-next-line no-await-in-loop
            const receipt = await tx.wait();
            if (receipt?.status !== 1) {
                (0, utils_1.logError)("Transaction failed");
            }
            (0, utils_1.logGreen)(quiet, (0, utils_1.success)(`Executed mergeMessageAqSubRoots(); gas used: ${receipt.gasUsed.toString()}`));
            (0, utils_1.logYellow)(quiet, (0, utils_1.info)(`Transaction hash: ${receipt.hash}`));
        }
    }
    // check if the message AQ has been fully merged
    const messageTreeDepth = Number((await pollContract.treeDepths()).messageTreeDepth);
    // check if the main root was not already computed
    const mainRoot = (await accQueueContract.getMainRoot(messageTreeDepth.toString())).toString();
    if (mainRoot === "0") {
        // go and merge the message tree
        (0, utils_1.logYellow)(quiet, (0, utils_1.info)("Merging subroots to a main message root..."));
        const tx = await pollContract.mergeMessageAq();
        const receipt = await tx.wait();
        if (receipt?.status !== 1) {
            (0, utils_1.logError)("Transaction failed");
        }
        (0, utils_1.logGreen)(quiet, (0, utils_1.success)(`Executed mergeMessageAq(); gas used: ${receipt.gasUsed.toString()}`));
        (0, utils_1.logYellow)(quiet, (0, utils_1.info)(`Transaction hash: ${receipt.hash}`));
        (0, utils_1.logGreen)(quiet, (0, utils_1.success)("The message tree has been merged."));
    }
    else {
        (0, utils_1.logYellow)(quiet, (0, utils_1.info)("The message tree has already been merged."));
    }
};
exports.mergeMessages = mergeMessages;
//# sourceMappingURL=mergeMessages.js.map