"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeSignups = void 0;
const maci_contracts_1 = require("maci-contracts");
const utils_1 = require("../utils");
/**
 * Command to merge the signups of a MACI contract
 * @param MergeSignupsArgs - The arguments for the mergeSignups command
 */
const mergeSignups = async ({ pollId, maciAddress, numQueueOps, signer, quiet = true, }) => {
    (0, utils_1.banner)(quiet);
    const network = await signer.provider?.getNetwork();
    // maci contract validation
    if (!(0, utils_1.readContractAddress)("MACI", network?.name) && !maciAddress) {
        (0, utils_1.logError)("Could not read contracts");
    }
    const maciContractAddress = maciAddress || (0, utils_1.readContractAddress)("MACI", network?.name);
    if (!(await (0, utils_1.contractExists)(signer.provider, maciContractAddress))) {
        (0, utils_1.logError)("MACI contract does not exist");
    }
    if (pollId < 0) {
        (0, utils_1.logError)("Invalid poll id");
    }
    const maciContract = maci_contracts_1.MACI__factory.connect(maciContractAddress, signer);
    const pollAddress = await maciContract.polls(pollId);
    if (!(await (0, utils_1.contractExists)(signer.provider, pollAddress))) {
        (0, utils_1.logError)("Poll contract does not exist");
    }
    const pollContract = maci_contracts_1.Poll__factory.connect(pollAddress, signer);
    const accQueueContract = maci_contracts_1.AccQueue__factory.connect(await maciContract.stateAq(), signer);
    // check if it's time to merge the message AQ
    const dd = await pollContract.getDeployTimeAndDuration();
    const deadline = Number(dd[0]) + Number(dd[1]);
    const now = await (0, utils_1.currentBlockTimestamp)(signer.provider);
    if (now < deadline) {
        (0, utils_1.logError)("Voting period is not over");
    }
    let subTreesMerged = false;
    // infinite loop to merge the sub trees
    while (!subTreesMerged) {
        // eslint-disable-next-line no-await-in-loop
        subTreesMerged = await accQueueContract.subTreesMerged();
        if (subTreesMerged) {
            (0, utils_1.logGreen)(quiet, (0, utils_1.success)("All state subtrees have been merged."));
        }
        else {
            // eslint-disable-next-line no-await-in-loop
            await accQueueContract
                .getSrIndices()
                .then((data) => data.map((x) => Number(x)))
                .then((indices) => {
                (0, utils_1.logYellow)(quiet, (0, utils_1.info)(`Merging state subroots ${indices[0] + 1} / ${indices[1] + 1}`));
            });
            // first merge the subroots
            // eslint-disable-next-line no-await-in-loop
            const tx = await pollContract.mergeMaciStateAqSubRoots(numQueueOps || utils_1.DEFAULT_SR_QUEUE_OPS, pollId.toString());
            // eslint-disable-next-line no-await-in-loop
            const receipt = await tx.wait();
            if (receipt?.status !== 1) {
                (0, utils_1.logError)("Error merging state subroots");
            }
            (0, utils_1.logYellow)(quiet, (0, utils_1.info)(`Transaction hash: ${receipt.hash}`));
            (0, utils_1.logGreen)(quiet, (0, utils_1.success)(`Executed mergeMaciStateAqSubRoots(); gas used: ${receipt.gasUsed.toString()}`));
        }
    }
    // check if the state AQ has been fully merged
    const stateTreeDepth = Number(await maciContract.stateTreeDepth());
    const mainRoot = (await accQueueContract.getMainRoot(stateTreeDepth.toString())).toString();
    if (mainRoot === "0" || pollId > 0) {
        // go and merge the state tree
        (0, utils_1.logYellow)(quiet, (0, utils_1.info)("Merging subroots to a main state root..."));
        const tx = await pollContract.mergeMaciStateAq(pollId.toString());
        const receipt = await tx.wait();
        if (receipt?.status !== 1) {
            (0, utils_1.logError)("Error merging state subroots");
        }
        (0, utils_1.logYellow)(quiet, (0, utils_1.info)(`Transaction hash: ${receipt.hash}`));
        (0, utils_1.logGreen)(quiet, (0, utils_1.success)(`Executed mergeStateAq(); gas used: ${receipt.gasUsed.toString()}`));
    }
    else {
        (0, utils_1.logYellow)(quiet, (0, utils_1.info)("The state tree has already been merged."));
    }
};
exports.mergeSignups = mergeSignups;
//# sourceMappingURL=mergeSignups.js.map