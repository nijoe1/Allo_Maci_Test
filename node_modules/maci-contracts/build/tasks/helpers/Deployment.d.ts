import { BaseContract, ContractFactory, Signer } from "ethers";
import type { TAbi } from "./types";
import type { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";
import type { ConfigurableTaskDefinition, HardhatRuntimeEnvironment, TaskArguments } from "hardhat/types";
import { EContracts, IDeployContractArgs, IDeployParams, IDeployStep, IGetContractParams } from "./types";
/**
 * @notice Deployment helper class to run sequential deploy using steps and deploy contracts.
 */
export declare class Deployment {
    /**
     * Singleton instance for class
     */
    private static INSTANCE?;
    /**
     * Hardhat runtime environment
     */
    private hre?;
    /**
     * Step catalog to create sequential tasks
     */
    private stepCatalog;
    /**
     * Json file database instance
     */
    private config;
    /**
     * Contract storage
     */
    private storage;
    /**
     * Initialize class properties only once
     */
    private constructor();
    /**
     * Get singleton object
     *
     * @returns {ContractStorage} singleton object
     */
    static getInstance(hre?: HardhatRuntimeEnvironment): Deployment;
    /**
     * Start deploy with console log information
     *
     * @param catalog - deploy steps catalog
     * @param {IDeployParams} params - deploy params
     * @returns deploy steps for selected catalog
     */
    start(catolog: string, { incremental, verify }: IDeployParams): Promise<IDeployStep[]>;
    /**
     * Run deploy steps
     *
     * @param steps - deploy steps
     * @param skip - skip steps with less or equal index
     */
    runSteps(steps: IDeployStep[], skip: number): Promise<void>;
    /**
     * Print deployment results and check warnings
     *
     * @param strict - fail on warnings is enabled
     * @throws error if strict is enabled and warning is found
     */
    checkResults(strict?: boolean): Promise<void>;
    /**
     * Finish deployment with console log information
     *
     * @param startBalance - start deployer balance
     * @param success - success or not
     */
    finish(startBalance: bigint, success: boolean): Promise<void>;
    /**
     * Get deployer (first signer) from hardhat runtime environment
     *
     * @returns {Promise<HardhatEthersSigner>} - signer
     */
    getDeployer(): Promise<HardhatEthersSigner>;
    /**
     * Set hardhat runtime environment
     *
     * @param hre - hardhat runtime environment
     */
    setHre(hre: HardhatRuntimeEnvironment): void;
    /**
     * Check if hardhat runtime environment is set
     *
     * @throws {Error} error if there is no hardhat runtime environment set
     */
    private checkHre;
    /**
     * Register deploy task by updating step catalog and return task definition
     *
     * @param taskName - unique task name
     * @param stepName - task description
     * @param paramsFn - optional function to override default task arguments
     * @returns {Promise<ConfigurableTaskDefinition>} hardhat task definition
     */
    deployTask(taskName: string, stepName: string, paramsFn?: (params: IDeployParams) => Promise<TaskArguments>): Promise<ConfigurableTaskDefinition>;
    /**
     * Register deployment step
     *
     * @param deployType - deploy type
     * @param {IDeployStepCatalog} - deploy step catalog name, description and param mapper
     */
    private addStep;
    /**
     * Get default params from hardhat task
     *
     * @param {IDeployParams} params - hardhat task arguments
     * @returns {Promise<TaskArguments>} params for deploy workflow
     */
    private getDefaultParams;
    /**
     * Get deploy step sequence
     *
     * @param deployType - deploy type
     * @param {IDeployParams} params - deploy params
     * @returns {Promise<IDeployStep[]>} deploy steps
     */
    private getDeploySteps;
    /**
     * Deploy contract and return it
     *
     * @param contractName - contract name
     * @param signer - signer
     * @param args - constructor arguments
     * @returns deployed contract
     */
    deployContract<T extends BaseContract>({ name, abi, bytecode, signer }: IDeployContractArgs, ...args: unknown[]): Promise<T>;
    /**
     * Deploy contract with linked libraries using contract factory
     *
     * @param contractFactory - ethers contract factory
     * @param args - constructor arguments
     * @returns deployed contract
     */
    deployContractWithLinkedLibraries<T extends BaseContract>(contractFactory: ContractFactory, ...args: unknown[]): Promise<T>;
    /**
     * Creates contract factory from abi and bytecode
     *
     * @param name - contract name
     * @param abi - Contract abi
     * @param bytecode - Contract linked bytecode
     * @param signer - signer
     * @returns contract factory with linked libraries
     */
    createContractFactory(abi: TAbi, bytecode: string, signer?: Signer): Promise<ContractFactory>;
    /**
     * Get deploy config field (see deploy-config.json)
     *
     * @param id - contract name
     * @param field - config field key
     * @returns config field value or null
     */
    getDeployConfigField<T = string | number | boolean>(id: EContracts, field: string, mustGet?: boolean): T;
    /**
     * Get contract by name and group key
     *
     * @param {IGetContractParams} params - params
     * @returns contract wrapper
     */
    getContract<T extends BaseContract>({ name, key, address, signer }: IGetContractParams): Promise<T>;
}
//# sourceMappingURL=Deployment.d.ts.map