"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployMaci = exports.deployPollFactory = exports.deployContractWithLinkedLibraries = exports.deployPoseidonContracts = exports.deployFreeForAllSignUpGatekeeper = exports.deploySignupTokenGatekeeper = exports.deploySignupToken = exports.deployConstantInitialVoiceCreditProxy = exports.deployVerifier = exports.deployMockVerifier = exports.deployVkRegistry = exports.deployTopupCredit = exports.deployContract = exports.linkPoseidonLibraries = void 0;
const ethers_1 = require("ethers");
const typechain_types_1 = require("../typechain-types");
const abi_1 = require("./abi");
const utils_1 = require("./utils");
/**
 * Link Poseidon libraries to a Smart Contract
 * @param solFileToLink - the name of the contract to link the libraries to
 * @param poseidonT3Address - the address of the PoseidonT3 contract
 * @param poseidonT4Address - the address of the PoseidonT4 contract
 * @param poseidonT5Address - the address of the PoseidonT5 contract
 * @param poseidonT6Address - the address of the PoseidonT6 contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns a contract factory with the libraries linked
 */
const linkPoseidonLibraries = async (solFileToLink, poseidonT3Address, poseidonT4Address, poseidonT5Address, poseidonT6Address, signer, quiet = false) => {
    (0, utils_1.log)(`Linking Poseidon libraries to ${solFileToLink}`, quiet);
    const { ethers } = await Promise.resolve().then(() => __importStar(require("hardhat")));
    const contractFactory = await ethers.getContractFactory(solFileToLink, {
        signer: signer || (await (0, utils_1.getDefaultSigner)()),
        libraries: {
            PoseidonT3: poseidonT3Address,
            PoseidonT4: poseidonT4Address,
            PoseidonT5: poseidonT5Address,
            PoseidonT6: poseidonT6Address,
        },
    });
    return contractFactory;
};
exports.linkPoseidonLibraries = linkPoseidonLibraries;
/**
 * Deploy a Smart Contract given a name and some arguments
 * @param contractName - the name of the contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @param args - the constructor arguments of the contract
 */
const deployContract = async (contractName, signer, quiet = false, ...args) => {
    (0, utils_1.log)(`Deploying ${contractName}`, quiet);
    const { ethers } = await Promise.resolve().then(() => __importStar(require("hardhat")));
    const contractFactory = await ethers.getContractFactory(contractName, signer || (await (0, utils_1.getDefaultSigner)()));
    const feeData = await (0, utils_1.getFeeData)();
    const contract = await contractFactory.deploy(...args, {
        maxFeePerGas: feeData?.maxFeePerGas,
        maxPriorityFeePerGas: feeData?.maxPriorityFeePerGas,
    });
    await contract.deploymentTransaction().wait();
    return contract;
};
exports.deployContract = deployContract;
/**
 * Deploy a TopupCredit contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed TopupCredit contract
 */
const deployTopupCredit = async (signer, quiet = false) => (0, exports.deployContract)("TopupCredit", signer, quiet);
exports.deployTopupCredit = deployTopupCredit;
/**
 * Deploy a VkRegistry contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed VkRegistry contract
 */
const deployVkRegistry = async (signer, quiet = false) => (0, exports.deployContract)("VkRegistry", signer, quiet);
exports.deployVkRegistry = deployVkRegistry;
/**
 * Deploy a MockVerifier contract (testing only)
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed MockVerifier contract
 */
const deployMockVerifier = async (signer, quiet = false) => (0, exports.deployContract)("MockVerifier", signer, quiet);
exports.deployMockVerifier = deployMockVerifier;
/**
 * Deploy a Verifier contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed Verifier contract
 */
const deployVerifier = async (signer, quiet = false) => (0, exports.deployContract)("Verifier", signer, quiet);
exports.deployVerifier = deployVerifier;
/**
 * Deploy a constant initial voice credit proxy contract
 * @param signer - the signer to use to deploy the contract
 * @param amount - the amount of initial voice credit to give to each user
 * @param quiet - whether to suppress console output
 * @returns the deployed ConstantInitialVoiceCreditProxy contract
 */
const deployConstantInitialVoiceCreditProxy = async (amount, signer, quiet = false) => (0, exports.deployContract)("ConstantInitialVoiceCreditProxy", signer, quiet, amount.toString());
exports.deployConstantInitialVoiceCreditProxy = deployConstantInitialVoiceCreditProxy;
/**
 * Deploy a SignUpToken contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed SignUpToken contract
 */
const deploySignupToken = async (signer, quiet = false) => (0, exports.deployContract)("SignUpToken", signer, quiet);
exports.deploySignupToken = deploySignupToken;
/**
 * Deploy a SignUpTokenGatekeeper contract
 * @param signUpTokenAddress - the address of the SignUpToken contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns a SignUpTokenGatekeeper contract
 */
const deploySignupTokenGatekeeper = async (signUpTokenAddress, signer, quiet = false) => (0, exports.deployContract)("SignUpTokenGatekeeper", signer, quiet, signUpTokenAddress);
exports.deploySignupTokenGatekeeper = deploySignupTokenGatekeeper;
/**
 * Deploy a FreeForAllGatekeeper contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed FreeForAllGatekeeper contract
 */
const deployFreeForAllSignUpGatekeeper = async (signer, quiet = false) => (0, exports.deployContract)("FreeForAllGatekeeper", signer, quiet);
exports.deployFreeForAllSignUpGatekeeper = deployFreeForAllSignUpGatekeeper;
/**
 * Deploy Poseidon contracts
 * @param signer - the signer to use to deploy the contracts
 * @param quiet - whether to suppress console output
 * @returns the deployed Poseidon contracts
 */
const deployPoseidonContracts = async (signer, { poseidonT3, poseidonT4, poseidonT5, poseidonT6 } = {}, quiet = false) => {
    const [PoseidonT3Contract, PoseidonT4Contract, PoseidonT5Contract, PoseidonT6Contract] = await Promise.all([
        !poseidonT3 ? await (0, exports.deployContract)("PoseidonT3", signer, quiet) : typechain_types_1.PoseidonT3__factory.connect(poseidonT3),
        !poseidonT4 ? await (0, exports.deployContract)("PoseidonT4", signer, quiet) : typechain_types_1.PoseidonT4__factory.connect(poseidonT4),
        !poseidonT5 ? await (0, exports.deployContract)("PoseidonT5", signer, quiet) : typechain_types_1.PoseidonT5__factory.connect(poseidonT5),
        !poseidonT6 ? await (0, exports.deployContract)("PoseidonT6", signer, quiet) : typechain_types_1.PoseidonT6__factory.connect(poseidonT6),
    ]);
    return {
        PoseidonT3Contract,
        PoseidonT4Contract,
        PoseidonT5Contract,
        PoseidonT6Contract,
    };
};
exports.deployPoseidonContracts = deployPoseidonContracts;
/**
 * Deploy a contract with linked libraries
 * @param contractFactory - the contract factory to use
 * @param name - the name of the contract
 * @param quiet - whether to suppress console output
 * @param args - the constructor arguments of the contract
 * @returns the deployed contract instance
 */
const deployContractWithLinkedLibraries = async (contractFactory, name, quiet = false, ...args) => {
    (0, utils_1.log)(`Deploying ${name}`, quiet);
    const feeData = await (0, utils_1.getFeeData)();
    const contract = await contractFactory.deploy(...args, {
        maxFeePerGas: feeData?.maxFeePerGas,
        maxPriorityFeePerGas: feeData?.maxPriorityFeePerGas,
    });
    await contract.deploymentTransaction().wait();
    return contract;
};
exports.deployContractWithLinkedLibraries = deployContractWithLinkedLibraries;
/**
 * Deploy a Poll Factory contract
 * @param signer - the signer object to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed Poll Factory contract
 */
const deployPollFactory = async (signer, quiet = false) => {
    const poseidonContracts = await (0, exports.deployPoseidonContracts)(signer, {}, quiet);
    const [poseidonT3Contract, poseidonT4Contract, poseidonT5Contract, poseidonT6Contract] = await Promise.all([
        poseidonContracts.PoseidonT3Contract.getAddress(),
        poseidonContracts.PoseidonT4Contract.getAddress(),
        poseidonContracts.PoseidonT5Contract.getAddress(),
        poseidonContracts.PoseidonT6Contract.getAddress(),
    ]);
    const contractFactory = await (0, exports.linkPoseidonLibraries)("PollFactory", poseidonT3Contract, poseidonT4Contract, poseidonT5Contract, poseidonT6Contract, signer, quiet);
    return (0, exports.deployContractWithLinkedLibraries)(contractFactory, "PollFactory", quiet);
};
exports.deployPollFactory = deployPollFactory;
/**
 * Deploy a MACI contract
 * @param {IDeployMaciArgs} args - deploy arguments
 * @returns {IDeployedMaci} the deployed MACI contract
 */
const deployMaci = async ({ signUpTokenGatekeeperContractAddress, initialVoiceCreditBalanceAddress, topupCreditContractAddress, signer, poseidonAddresses, stateTreeDepth = 10, useQv = true, quiet = true, }) => {
    const { PoseidonT3Contract, PoseidonT4Contract, PoseidonT5Contract, PoseidonT6Contract } = await (0, exports.deployPoseidonContracts)(signer, poseidonAddresses, quiet);
    const poseidonAddrs = await Promise.all([
        PoseidonT3Contract.getAddress(),
        PoseidonT4Contract.getAddress(),
        PoseidonT5Contract.getAddress(),
        PoseidonT6Contract.getAddress(),
    ]).then(([poseidonT3, poseidonT4, poseidonT5, poseidonT6]) => ({
        poseidonT3,
        poseidonT4,
        poseidonT5,
        poseidonT6,
    }));
    const contractsToLink = [
        "MACI",
        "PollFactory",
        "MessageProcessorFactory",
        "TallyFactory",
        "TallyNonQvFactory",
        "SubsidyFactory",
    ];
    // Link Poseidon contracts to MACI
    const linkedContractFactories = await Promise.all(contractsToLink.map(async (contractName) => (0, exports.linkPoseidonLibraries)(contractName, poseidonAddrs.poseidonT3, poseidonAddrs.poseidonT4, poseidonAddrs.poseidonT5, poseidonAddrs.poseidonT6, signer, quiet)));
    const [maciContractFactory, pollFactoryContractFactory, messageProcessorFactory, tallyFactory, tallyFactoryNonQv, subsidyFactory,] = await Promise.all(linkedContractFactories);
    const pollFactoryContract = await (0, exports.deployContractWithLinkedLibraries)(pollFactoryContractFactory, "PollFactory", quiet);
    const messageProcessorFactoryContract = await (0, exports.deployContractWithLinkedLibraries)(messageProcessorFactory, "MessageProcessorFactory", quiet);
    // deploy either the qv or non qv tally factory - they both implement the same interface
    // so as long as maci is concerned, they are interchangeable
    const tallyFactoryContract = useQv
        ? await (0, exports.deployContractWithLinkedLibraries)(tallyFactory, "TallyFactory", quiet)
        : await (0, exports.deployContractWithLinkedLibraries)(tallyFactoryNonQv, "TallyNonQvFactory", quiet);
    const subsidyFactoryContract = await (0, exports.deployContractWithLinkedLibraries)(subsidyFactory, "SubsidyFactory", quiet);
    const [pollAddr, mpAddr, tallyAddr, subsidyAddr] = await Promise.all([
        pollFactoryContract.getAddress(),
        messageProcessorFactoryContract.getAddress(),
        tallyFactoryContract.getAddress(),
        subsidyFactoryContract.getAddress(),
    ]);
    const maciContract = await (0, exports.deployContractWithLinkedLibraries)(maciContractFactory, "MACI", quiet, pollAddr, mpAddr, tallyAddr, subsidyAddr, signUpTokenGatekeeperContractAddress, initialVoiceCreditBalanceAddress, topupCreditContractAddress, stateTreeDepth);
    const [AccQueueQuinaryMaciAbi] = (0, abi_1.parseArtifact)("AccQueue");
    const stateAqContractAddress = await maciContract.stateAq();
    const stateAqContract = new ethers_1.BaseContract(stateAqContractAddress, AccQueueQuinaryMaciAbi, await (0, utils_1.getDefaultSigner)());
    return {
        maciContract,
        stateAqContract,
        pollFactoryContract,
        poseidonAddrs,
    };
};
exports.deployMaci = deployMaci;
//# sourceMappingURL=deploy.js.map