"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployMaci = exports.deployPollFactory = exports.deployContractWithLinkedLibraries = exports.deployPoseidonContracts = exports.deployFreeForAllSignUpGatekeeper = exports.deploySignupTokenGatekeeper = exports.deploySignupToken = exports.deployConstantInitialVoiceCreditProxy = exports.deployVerifier = exports.deployMockVerifier = exports.deployVkRegistry = exports.deployTopupCredit = exports.deployContract = exports.createContractFactory = void 0;
const Deployment_1 = require("../tasks/helpers/Deployment");
const typechain_types_1 = require("../typechain-types");
const utils_1 = require("./utils");
/**
 * Creates contract factory from abi and bytecode
 *
 * @param abi - Contract abi
 * @param bytecode - Contract bytecode
 * @param signer - the signer to use to deploy the contract
 * @returns a contract factory with the libraries linked
 */
const createContractFactory = async (abi, bytecode, signer) => {
    const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
    const deployment = Deployment_1.Deployment.getInstance(hre);
    deployment.setHre(hre);
    const deployer = signer || (await deployment.getDeployer());
    return deployment.createContractFactory(abi, bytecode, deployer);
};
exports.createContractFactory = createContractFactory;
/**
 * Deploy a Smart Contract given a name and some arguments
 * @param contractName - the name of the contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @param args - the constructor arguments of the contract
 */
const deployContract = async (contractName, signer, quiet = false, ...args) => {
    (0, utils_1.log)(`Deploying ${contractName}`, quiet);
    const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
    const deployment = Deployment_1.Deployment.getInstance(hre);
    deployment.setHre(hre);
    return deployment.deployContract({ name: contractName, signer }, ...args);
};
exports.deployContract = deployContract;
/**
 * Deploy a TopupCredit contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed TopupCredit contract
 */
const deployTopupCredit = async (signer, quiet = false) => (0, exports.deployContract)("TopupCredit", signer, quiet);
exports.deployTopupCredit = deployTopupCredit;
/**
 * Deploy a VkRegistry contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed VkRegistry contract
 */
const deployVkRegistry = async (signer, quiet = false) => (0, exports.deployContract)("VkRegistry", signer, quiet);
exports.deployVkRegistry = deployVkRegistry;
/**
 * Deploy a MockVerifier contract (testing only)
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed MockVerifier contract
 */
const deployMockVerifier = async (signer, quiet = false) => (0, exports.deployContract)("MockVerifier", signer, quiet);
exports.deployMockVerifier = deployMockVerifier;
/**
 * Deploy a Verifier contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed Verifier contract
 */
const deployVerifier = async (signer, quiet = false) => (0, exports.deployContract)("Verifier", signer, quiet);
exports.deployVerifier = deployVerifier;
/**
 * Deploy a constant initial voice credit proxy contract
 * @param signer - the signer to use to deploy the contract
 * @param amount - the amount of initial voice credit to give to each user
 * @param quiet - whether to suppress console output
 * @returns the deployed ConstantInitialVoiceCreditProxy contract
 */
const deployConstantInitialVoiceCreditProxy = async (amount, signer, quiet = false) => (0, exports.deployContract)("ConstantInitialVoiceCreditProxy", signer, quiet, amount.toString());
exports.deployConstantInitialVoiceCreditProxy = deployConstantInitialVoiceCreditProxy;
/**
 * Deploy a SignUpToken contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed SignUpToken contract
 */
const deploySignupToken = async (signer, quiet = false) => (0, exports.deployContract)("SignUpToken", signer, quiet);
exports.deploySignupToken = deploySignupToken;
/**
 * Deploy a SignUpTokenGatekeeper contract
 * @param signUpTokenAddress - the address of the SignUpToken contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns a SignUpTokenGatekeeper contract
 */
const deploySignupTokenGatekeeper = async (signUpTokenAddress, signer, quiet = false) => (0, exports.deployContract)("SignUpTokenGatekeeper", signer, quiet, signUpTokenAddress);
exports.deploySignupTokenGatekeeper = deploySignupTokenGatekeeper;
/**
 * Deploy a FreeForAllGatekeeper contract
 * @param signer - the signer to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed FreeForAllGatekeeper contract
 */
const deployFreeForAllSignUpGatekeeper = async (signer, quiet = false) => (0, exports.deployContract)("FreeForAllGatekeeper", signer, quiet);
exports.deployFreeForAllSignUpGatekeeper = deployFreeForAllSignUpGatekeeper;
/**
 * Deploy Poseidon contracts
 * @param signer - the signer to use to deploy the contracts
 * @param quiet - whether to suppress console output
 * @returns the deployed Poseidon contracts
 */
const deployPoseidonContracts = async (signer, { poseidonT3, poseidonT4, poseidonT5, poseidonT6 } = {}, quiet = false) => {
    const [PoseidonT3Contract, PoseidonT4Contract, PoseidonT5Contract, PoseidonT6Contract] = await Promise.all([
        !poseidonT3 ? await (0, exports.deployContract)("PoseidonT3", signer, quiet) : typechain_types_1.PoseidonT3__factory.connect(poseidonT3),
        !poseidonT4 ? await (0, exports.deployContract)("PoseidonT4", signer, quiet) : typechain_types_1.PoseidonT4__factory.connect(poseidonT4),
        !poseidonT5 ? await (0, exports.deployContract)("PoseidonT5", signer, quiet) : typechain_types_1.PoseidonT5__factory.connect(poseidonT5),
        !poseidonT6 ? await (0, exports.deployContract)("PoseidonT6", signer, quiet) : typechain_types_1.PoseidonT6__factory.connect(poseidonT6),
    ]);
    return {
        PoseidonT3Contract,
        PoseidonT4Contract,
        PoseidonT5Contract,
        PoseidonT6Contract,
    };
};
exports.deployPoseidonContracts = deployPoseidonContracts;
/**
 * Deploy a contract with linked libraries
 * @param contractFactory - the contract factory to use
 * @param name - the name of the contract
 * @param quiet - whether to suppress console output
 * @param args - the constructor arguments of the contract
 * @returns the deployed contract instance
 */
const deployContractWithLinkedLibraries = async (contractFactory, ...args) => {
    const hre = await Promise.resolve().then(() => __importStar(require("hardhat")));
    const deployment = Deployment_1.Deployment.getInstance(hre);
    deployment.setHre(hre);
    return deployment.deployContractWithLinkedLibraries(contractFactory, ...args);
};
exports.deployContractWithLinkedLibraries = deployContractWithLinkedLibraries;
/**
 * Deploy a Poll Factory contract
 * @param signer - the signer object to use to deploy the contract
 * @param quiet - whether to suppress console output
 * @returns the deployed Poll Factory contract
 */
const deployPollFactory = async (signer, quiet = false) => {
    const poseidonContracts = await (0, exports.deployPoseidonContracts)(signer, {}, quiet);
    const [poseidonT3Contract, poseidonT4Contract, poseidonT5Contract, poseidonT6Contract] = await Promise.all([
        poseidonContracts.PoseidonT3Contract.getAddress(),
        poseidonContracts.PoseidonT4Contract.getAddress(),
        poseidonContracts.PoseidonT5Contract.getAddress(),
        poseidonContracts.PoseidonT6Contract.getAddress(),
    ]);
    const contractFactory = await (0, exports.createContractFactory)(typechain_types_1.PollFactory__factory.abi, typechain_types_1.PollFactory__factory.linkBytecode({
        "contracts/crypto/PoseidonT3.sol:PoseidonT3": poseidonT3Contract,
        "contracts/crypto/PoseidonT4.sol:PoseidonT4": poseidonT4Contract,
        "contracts/crypto/PoseidonT5.sol:PoseidonT5": poseidonT5Contract,
        "contracts/crypto/PoseidonT6.sol:PoseidonT6": poseidonT6Contract,
    }), signer);
    return (0, exports.deployContractWithLinkedLibraries)(contractFactory);
};
exports.deployPollFactory = deployPollFactory;
/**
 * Deploy a MACI contract
 * @param {IDeployMaciArgs} args - deploy arguments
 * @returns {IDeployedMaci} the deployed MACI contract
 */
const deployMaci = async ({ signUpTokenGatekeeperContractAddress, initialVoiceCreditBalanceAddress, topupCreditContractAddress, signer, poseidonAddresses, stateTreeDepth = 10, quiet = true, }) => {
    const { PoseidonT3Contract, PoseidonT4Contract, PoseidonT5Contract, PoseidonT6Contract } = await (0, exports.deployPoseidonContracts)(signer, poseidonAddresses, quiet);
    const poseidonAddrs = await Promise.all([
        PoseidonT3Contract.getAddress(),
        PoseidonT4Contract.getAddress(),
        PoseidonT5Contract.getAddress(),
        PoseidonT6Contract.getAddress(),
    ]).then(([poseidonT3, poseidonT4, poseidonT5, poseidonT6]) => ({
        poseidonT3,
        poseidonT4,
        poseidonT5,
        poseidonT6,
    }));
    const contractsToLink = [typechain_types_1.MACI__factory, typechain_types_1.PollFactory__factory, typechain_types_1.MessageProcessorFactory__factory, typechain_types_1.TallyFactory__factory];
    // Link Poseidon contracts to MACI
    const linkedContractFactories = await Promise.all(contractsToLink.map(async (factory) => (0, exports.createContractFactory)(factory.abi, factory.linkBytecode({
        "contracts/crypto/PoseidonT3.sol:PoseidonT3": poseidonAddrs.poseidonT3,
        "contracts/crypto/PoseidonT4.sol:PoseidonT4": poseidonAddrs.poseidonT4,
        "contracts/crypto/PoseidonT5.sol:PoseidonT5": poseidonAddrs.poseidonT5,
        "contracts/crypto/PoseidonT6.sol:PoseidonT6": poseidonAddrs.poseidonT6,
    }), signer)));
    const [maciContractFactory, pollFactoryContractFactory, messageProcessorFactory, tallyFactory] = await Promise.all(linkedContractFactories);
    const pollFactoryContract = await (0, exports.deployContractWithLinkedLibraries)(pollFactoryContractFactory);
    const messageProcessorFactoryContract = await (0, exports.deployContractWithLinkedLibraries)(messageProcessorFactory);
    const tallyFactoryContract = await (0, exports.deployContractWithLinkedLibraries)(tallyFactory);
    const [pollAddress, messageProcessorAddress, tallyAddress] = await Promise.all([
        pollFactoryContract.getAddress(),
        messageProcessorFactoryContract.getAddress(),
        tallyFactoryContract.getAddress(),
    ]);
    const maciContract = await (0, exports.deployContractWithLinkedLibraries)(maciContractFactory, pollAddress, messageProcessorAddress, tallyAddress, signUpTokenGatekeeperContractAddress, initialVoiceCreditBalanceAddress, topupCreditContractAddress, stateTreeDepth);
    const [stateAqContractAddress, deployer] = await Promise.all([maciContract.stateAq(), (0, utils_1.getDefaultSigner)()]);
    const stateAqContract = typechain_types_1.AccQueueQuinaryMaci__factory.connect(stateAqContractAddress, signer || deployer);
    return {
        maciContract,
        stateAqContract,
        pollFactoryContract,
        poseidonAddrs,
    };
};
exports.deployMaci = deployMaci;
//# sourceMappingURL=deploy.js.map