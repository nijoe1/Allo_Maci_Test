"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.genMaciStateFromContract = void 0;
/* eslint-disable no-underscore-dangle */
const ethers_1 = require("ethers");
const maci_core_1 = require("maci-core");
const maci_domainobjs_1 = require("maci-domainobjs");
const assert_1 = __importDefault(require("assert"));
const abi_1 = require("./abi");
const utils_1 = require("./utils");
/**
 * Generate a MaciState object from the events of a MACI and Poll smart contracts
 * @param provider - the ethereum provider
 * @param address - the address of the MACI contract
 * @param coordinatorKeypair - the keypair of the coordinator
 * @param pollId - the id of the poll for which we are fetching events
 * @param fromBlock - the block number from which to start fetching events
 * @param blocksPerRequest - the number of blocks to fetch in each request
 * @param endBlock - the block number at which to stop fetching events
 * @param sleepAmount - the amount of time to sleep between each request
 * @returns an instance of MaciState
 */
const genMaciStateFromContract = async (provider, address, coordinatorKeypair, pollId, fromBlock = 0, blocksPerRequest = 50, endBlock = undefined, sleepAmount = undefined) => {
    // ensure the pollId is valid
    (0, assert_1.default)(pollId >= 0);
    const [pollContractAbi] = (0, abi_1.parseArtifact)("Poll");
    const [maciContractAbi] = (0, abi_1.parseArtifact)("MACI");
    const maciContract = new ethers_1.BaseContract(address, maciContractAbi, provider);
    const maciIface = new ethers_1.Interface(maciContractAbi);
    const pollIface = new ethers_1.Interface(pollContractAbi);
    // Check stateTreeDepth
    const stateTreeDepth = await maciContract.stateTreeDepth();
    // we need to pass the stateTreeDepth
    const maciState = new maci_core_1.MaciState(Number(stateTreeDepth));
    // ensure it is set correctly
    (0, assert_1.default)(stateTreeDepth === BigInt(maciState.stateTreeDepth));
    let signUpLogs = [];
    let deployPollLogs = [];
    // if no last block is set then we fetch until the current block number
    const lastBlock = endBlock || (await provider.getBlockNumber());
    // Fetch event logs in batches (lastBlock inclusive)
    for (let i = fromBlock; i <= lastBlock; i += blocksPerRequest + 1) {
        // the last block batch will be either current iteration block + blockPerRequest
        // or the end block if it is set
        const toBlock = i + blocksPerRequest >= lastBlock ? lastBlock : i + blocksPerRequest;
        const [tmpSignUpLogs, tmpDeployPollLogs] = 
        // eslint-disable-next-line no-await-in-loop
        await Promise.all([
            maciContract.queryFilter(maciContract.filters.SignUp(), i, toBlock),
            maciContract.queryFilter(maciContract.filters.DeployPoll(), i, toBlock),
        ]);
        signUpLogs = signUpLogs.concat(tmpSignUpLogs);
        deployPollLogs = deployPollLogs.concat(tmpDeployPollLogs);
        if (sleepAmount) {
            // eslint-disable-next-line no-await-in-loop
            await (0, utils_1.sleep)(sleepAmount);
        }
    }
    let actions = [];
    signUpLogs.forEach((log) => {
        (0, assert_1.default)(!!log);
        const mutableLog = { ...log, topics: [...log.topics] };
        const event = maciIface.parseLog(mutableLog);
        actions.push({
            type: "SignUp",
            blockNumber: log.blockNumber,
            transactionIndex: log.transactionIndex,
            data: {
                stateIndex: Number(event.args._stateIndex),
                pubKey: new maci_domainobjs_1.PubKey([BigInt(event.args._userPubKeyX), BigInt(event.args._userPubKeyY)]),
                voiceCreditBalance: Number(event.args._voiceCreditBalance),
                timestamp: Number(event.args._timestamp),
            },
        });
    });
    let index = 0n;
    const foundPollIds = [];
    const pollContractAddresses = new Map();
    deployPollLogs.forEach((log) => {
        (0, assert_1.default)(!!log);
        const mutableLogs = { ...log, topics: [...log.topics] };
        const event = maciIface.parseLog(mutableLogs);
        const pubKey = new maci_domainobjs_1.PubKey([BigInt(event.args._coordinatorPubKeyX), BigInt(event.args._coordinatorPubKeyY)]);
        const p = event.args._pollId;
        (0, assert_1.default)(p === index);
        const pollAddr = event.args.pollAddr.poll;
        actions.push({
            type: "DeployPoll",
            blockNumber: log.blockNumber,
            transactionIndex: log.transactionIndex,
            data: { pollId: p, pollAddr, pubKey },
        });
        foundPollIds.push(Number(p));
        pollContractAddresses.set(BigInt(p), pollAddr);
        index += 1n;
    });
    // Check whether each pollId exists
    (0, assert_1.default)(foundPollIds.includes(Number(pollId)), "Error: the specified pollId does not exist on-chain");
    const pollContractAddress = pollContractAddresses.get(pollId);
    const pollContract = new ethers_1.BaseContract(pollContractAddress, pollContractAbi, provider);
    const coordinatorPubKeyOnChain = await pollContract.coordinatorPubKey();
    (0, assert_1.default)(coordinatorPubKeyOnChain[0].toString() === coordinatorKeypair.pubKey.rawPubKey[0].toString());
    (0, assert_1.default)(coordinatorPubKeyOnChain[1].toString() === coordinatorKeypair.pubKey.rawPubKey[1].toString());
    const dd = await pollContract.getDeployTimeAndDuration();
    const deployTime = Number(dd[0]);
    const duration = Number(dd[1]);
    const onChainMaxValues = await pollContract.maxValues();
    const onChainTreeDepths = await pollContract.treeDepths();
    const maxValues = {
        maxMessages: Number(onChainMaxValues.maxMessages),
        maxVoteOptions: Number(onChainMaxValues.maxVoteOptions),
    };
    const treeDepths = {
        intStateTreeDepth: Number(onChainTreeDepths.intStateTreeDepth),
        messageTreeDepth: Number(onChainTreeDepths.messageTreeDepth),
        messageTreeSubDepth: Number(onChainTreeDepths.messageTreeSubDepth),
        voteOptionTreeDepth: Number(onChainTreeDepths.voteOptionTreeDepth),
    };
    const batchSizes = {
        tallyBatchSize: maci_core_1.STATE_TREE_ARITY ** Number(onChainTreeDepths.intStateTreeDepth),
        subsidyBatchSize: maci_core_1.STATE_TREE_ARITY ** Number(onChainTreeDepths.intStateTreeDepth),
        messageBatchSize: maci_core_1.STATE_TREE_ARITY ** Number(onChainTreeDepths.messageTreeSubDepth),
    };
    // fetch poll contract logs
    let publishMessageLogs = [];
    let topupLogs = [];
    let mergeMaciStateAqSubRootsLogs = [];
    let mergeMaciStateAqLogs = [];
    let mergeMessageAqSubRootsLogs = [];
    let mergeMessageAqLogs = [];
    for (let i = fromBlock; i <= lastBlock; i += blocksPerRequest + 1) {
        const toBlock = i + blocksPerRequest >= lastBlock ? lastBlock : i + blocksPerRequest;
        const [tmpPublishMessageLogs, tmpTopupLogs, tmpMergeMaciStateAqSubRootsLogs, tmpMergeMaciStateAqLogs, tmpMergeMessageAqSubRootsLogs, tmpMergeMessageAqLogs,
        // eslint-disable-next-line no-await-in-loop
        ] = await Promise.all([
            pollContract.queryFilter(pollContract.filters.PublishMessage(), i, toBlock),
            pollContract.queryFilter(pollContract.filters.TopupMessage(), i, toBlock),
            pollContract.queryFilter(pollContract.filters.MergeMaciStateAqSubRoots(), i, toBlock),
            pollContract.queryFilter(pollContract.filters.MergeMaciStateAq(), i, toBlock),
            pollContract.queryFilter(pollContract.filters.MergeMessageAqSubRoots(), i, toBlock),
            pollContract.queryFilter(pollContract.filters.MergeMessageAq(), i, toBlock),
        ]);
        publishMessageLogs = publishMessageLogs.concat(tmpPublishMessageLogs);
        topupLogs = topupLogs.concat(tmpTopupLogs);
        mergeMaciStateAqSubRootsLogs = mergeMaciStateAqSubRootsLogs.concat(tmpMergeMaciStateAqSubRootsLogs);
        mergeMaciStateAqLogs = mergeMaciStateAqLogs.concat(tmpMergeMaciStateAqLogs);
        mergeMessageAqSubRootsLogs = mergeMessageAqSubRootsLogs.concat(tmpMergeMessageAqSubRootsLogs);
        mergeMessageAqLogs = mergeMessageAqLogs.concat(tmpMergeMessageAqLogs);
        if (sleepAmount) {
            // eslint-disable-next-line no-await-in-loop
            await (0, utils_1.sleep)(sleepAmount);
        }
    }
    publishMessageLogs.forEach((log) => {
        (0, assert_1.default)(!!log);
        const mutableLogs = { ...log, topics: [...log.topics] };
        const event = pollIface.parseLog(mutableLogs);
        const message = new maci_domainobjs_1.Message(BigInt(event.args._message[0]), event.args._message[1].map((x) => BigInt(x)));
        const encPubKey = new maci_domainobjs_1.PubKey(event.args._encPubKey.map((x) => BigInt(x.toString())));
        actions.push({
            type: "PublishMessage",
            blockNumber: log.blockNumber,
            transactionIndex: log.transactionIndex,
            data: {
                message,
                encPubKey,
            },
        });
    });
    topupLogs.forEach((log) => {
        (0, assert_1.default)(!!log);
        const mutableLog = { ...log, topics: [...log.topics] };
        const event = pollIface.parseLog(mutableLog);
        const message = new maci_domainobjs_1.Message(BigInt(event.args._message[0]), event.args._message[1].map((x) => BigInt(x)));
        actions.push({
            type: "TopupMessage",
            blockNumber: log.blockNumber,
            transactionIndex: log.transactionIndex,
            data: {
                message,
            },
        });
    });
    mergeMessageAqSubRootsLogs.forEach((log) => {
        (0, assert_1.default)(!!log);
        const mutableLogs = { ...log, topics: [...log.topics] };
        const event = pollIface.parseLog(mutableLogs);
        const numSrQueueOps = Number(event.args._numSrQueueOps);
        actions.push({
            type: "MergeMessageAqSubRoots",
            blockNumber: log.blockNumber,
            transactionIndex: log.transactionIndex,
            data: {
                numSrQueueOps,
            },
        });
    });
    mergeMessageAqLogs.forEach((log) => {
        (0, assert_1.default)(!!log);
        const mutableLogs = { ...log, topics: [...log.topics] };
        const event = pollIface.parseLog(mutableLogs);
        const messageRoot = BigInt((event?.args)._messageRoot);
        actions.push({
            type: "MergeMessageAq",
            blockNumber: log.blockNumber,
            transactionIndex: log.transactionIndex,
            data: { messageRoot },
        });
    });
    // Sort actions
    actions = (0, utils_1.sortActions)(actions);
    // Reconstruct MaciState in order
    actions.forEach((action) => {
        switch (true) {
            case action.type === "SignUp": {
                const { pubKey, voiceCreditBalance, timestamp } = action.data;
                maciState.signUp(pubKey, BigInt(voiceCreditBalance), BigInt(timestamp));
                break;
            }
            case action.type === "DeployPoll" && action.data.pollId?.toString() === pollId.toString(): {
                maciState.deployPoll(BigInt(deployTime + duration), maxValues, treeDepths, batchSizes.messageBatchSize, coordinatorKeypair);
                break;
            }
            case action.type === "DeployPoll" && action.data.pollId?.toString() !== pollId.toString(): {
                maciState.deployNullPoll();
                break;
            }
            case action.type === "PublishMessage": {
                const { encPubKey, message } = action.data;
                maciState.polls.get(pollId)?.publishMessage(message, encPubKey);
                break;
            }
            case action.type === "TopupMessage": {
                const { message } = action.data;
                maciState.polls.get(pollId)?.topupMessage(message);
                break;
            }
            // ensure that the message root is correct (i.e. all messages have been published offchain)
            case action.type === "MergeMessageAq": {
                (0, assert_1.default)(maciState.polls.get(pollId)?.messageTree.root.toString() === action.data.messageRoot?.toString());
                break;
            }
            default:
                break;
        }
    });
    // Set numSignUps
    const numSignUpsAndMessages = await pollContract.numSignUpsAndMessages();
    const poll = maciState.polls.get(pollId);
    // ensure all messages were recorded
    (0, assert_1.default)(Number(numSignUpsAndMessages[1]) === poll?.messages.length);
    // set the number of signups
    poll.updatePoll(numSignUpsAndMessages[0]);
    // we need to ensure that the stateRoot is correct
    (0, assert_1.default)(poll.stateTree?.root.toString() === (await pollContract.mergedStateRoot()).toString());
    maciState.polls.set(pollId, poll);
    return maciState;
};
exports.genMaciStateFromContract = genMaciStateFromContract;
//# sourceMappingURL=genMaciState.js.map