"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unpackTallyVotesSmallVals = exports.packTallyVotesSmallVals = exports.unpackProcessMessageSmallVals = exports.packProcessMessageSmallVals = exports.genTallyVkSig = exports.genProcessVkSig = void 0;
/* eslint-disable no-bitwise */
const assert_1 = __importDefault(require("assert"));
/**
 * This function generates the signature of a ProcessMessage Verifying Key(VK).
 * This can be used to check if a ProcessMessages' circuit VK is registered
 * in a smart contract that holds several VKs.
 * @param stateTreeDepth - The depth of the state tree.
 * @param messageTreeDepth - The depth of the message tree.
 * @param voteOptionTreeDepth - The depth of the vote option tree.
 * @param batchSize - The size of the batch.
 * @returns Returns a signature for querying if a verifying key with the given parameters is already registered in the contract.
 */
const genProcessVkSig = (stateTreeDepth, messageTreeDepth, voteOptionTreeDepth, batchSize) => (BigInt(batchSize) << 192n) +
    (BigInt(stateTreeDepth) << 128n) +
    (BigInt(messageTreeDepth) << 64n) +
    BigInt(voteOptionTreeDepth);
exports.genProcessVkSig = genProcessVkSig;
/**
 * This function generates the signature of a Tally Verifying Key(VK).
 * This can be used to check if a TallyVotes' circuit VK is registered
 * in a smart contract that holds several VKs.
 * @param _stateTreeDepth - The depth of the state tree.
 * @param _intStateTreeDepth - The depth of the intermediate state tree.
 * @param _voteOptionTreeDepth - The depth of the vote option tree.
 * @returns Returns a signature for querying if a verifying key with
 * the given parameters is already registered in the contract.
 */
const genTallyVkSig = (_stateTreeDepth, _intStateTreeDepth, _voteOptionTreeDepth) => (BigInt(_stateTreeDepth) << 128n) + (BigInt(_intStateTreeDepth) << 64n) + BigInt(_voteOptionTreeDepth);
exports.genTallyVkSig = genTallyVkSig;
/**
 * This function packs it's parameters into a single bigint.
 * @param maxVoteOptions - The maximum number of vote options.
 * @param numUsers - The number of users.
 * @param batchStartIndex - The start index of the batch.
 * @param batchEndIndex - The end index of the batch.
 * @returns Returns a single bigint that contains the packed values.
 */
const packProcessMessageSmallVals = (maxVoteOptions, numUsers, batchStartIndex, batchEndIndex) => {
    const packedVals = 
    // Note: the << operator has lower precedence than +
    BigInt(`${maxVoteOptions}`) +
        (BigInt(`${numUsers}`) << 50n) +
        (BigInt(batchStartIndex) << 100n) +
        (BigInt(batchEndIndex) << 150n);
    return packedVals;
};
exports.packProcessMessageSmallVals = packProcessMessageSmallVals;
/**
 * This function unpacks partial values for the ProcessMessages circuit from a single bigint.
 * @param packedVals - The single bigint that contains the packed values.
 * @returns Returns an object that contains the unpacked values.
 */
const unpackProcessMessageSmallVals = (packedVals) => {
    let asBin = packedVals.toString(2);
    (0, assert_1.default)(asBin.length <= 200);
    while (asBin.length < 200) {
        asBin = `0${asBin}`;
    }
    const maxVoteOptions = BigInt(`0b${asBin.slice(150, 200)}`);
    const numUsers = BigInt(`0b${asBin.slice(100, 150)}`);
    const batchStartIndex = BigInt(`0b${asBin.slice(50, 100)}`);
    const batchEndIndex = BigInt(`0b${asBin.slice(0, 50)}`);
    return {
        maxVoteOptions,
        numUsers,
        batchStartIndex,
        batchEndIndex,
    };
};
exports.unpackProcessMessageSmallVals = unpackProcessMessageSmallVals;
/**
 * This function packs it's parameters into a single bigint.
 * @param batchStartIndex - The start index of the batch.
 * @param batchSize - The size of the batch.
 * @param numSignUps - The number of signups.
 * @returns Returns a single bigint that contains the packed values.
 */
const packTallyVotesSmallVals = (batchStartIndex, batchSize, numSignUps) => {
    // Note: the << operator has lower precedence than +
    const packedVals = BigInt(batchStartIndex) / BigInt(batchSize) + (BigInt(numSignUps) << 50n);
    return packedVals;
};
exports.packTallyVotesSmallVals = packTallyVotesSmallVals;
/**
 * This function unpacks partial values for the TallyVotes circuit from a single bigint.
 * @param packedVals - The single bigint that contains the packed values.
 * @returns Returns an object that contains the unpacked values.
 */
const unpackTallyVotesSmallVals = (packedVals) => {
    let asBin = packedVals.toString(2);
    (0, assert_1.default)(asBin.length <= 100);
    while (asBin.length < 100) {
        asBin = `0${asBin}`;
    }
    const numSignUps = BigInt(`0b${asBin.slice(0, 50)}`);
    const batchStartIndex = BigInt(`0b${asBin.slice(50, 100)}`);
    return { numSignUps, batchStartIndex };
};
exports.unpackTallyVotesSmallVals = unpackTallyVotesSmallVals;
//# sourceMappingURL=utils.js.map